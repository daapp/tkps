#!/usr/bin/tclsh
#  \
exec tclsh "$0" ${1+"$@"}
# This script generates a process browser, which lists the running
# processes (using unix "ps") and allows you to send signals (such as KILL)
# using a popup menu. 

# Create a scrollbar on the right side of the main window and a listbox
# on the left side.
#
# Adapted/enhanced for Linux by Ed Petron (epetron@leba.net)
# Kidong Lee (kidong@shinbiro.com) May 1997
#
# Originally written by Henry Minsky (hqm@ai.mit.edu) May 1994
# 

################################################################
# You can get the implementation dependent signal names for your system
# from /usr/include/signal.h
# 
package require Tk
package require Ttk

tcl::tm::path add $env(HOME)/lib/tcl

package require tkapp
package require widget::scrolledwindow
package require widget::dialog
package require tablelist
package require textutil
package require fileutil

namespace import tkapp::w

set application tkps
set version 1.25

set systemRCFile "/etc/${application}rc"
set userRCFile ""
switch $tcl_platform(platform) {
    "unix" {
        if {[info exists env(DOTDIR)]} {
            set userRCFile [file join $env(DOTDIR) .${application}rc]
        } else {
            set userRCFile [file join $env(HOME) .${application}rc]
        }
    }
    default {
        error "System $tcl_platform(platform) is not supported."
    }
}


set common_sigs {
    {INT         2        interupt}
    {QUIT        3        quit}
    {IOT         6        abort}
    {KILL        9        non-catchable, non-ignorable kill}
    {STOP        17       sendable stop signal not from tty}
    {ALRM        14       alarm clock}
    {TERM        15       software termination signal}
}

set all_sigs {
    {HUP         1         hangup}
    {INT         2         interrupt}
    {QUIT        3         quit}
    {ILL         4         illegal instruction (not reset when caught)}
    {TRAP        5         trace trap (not reset when caught)}
    {ABRT        6         abort()}
    {IOT         6         SIGABRT compatibility}
    {EMT         7         EMT instruction}
    {FPE         8         floating point exception}
    {KILL        9         kill (cannot be caught or ignored)}
    {BUS         10        bus error}
    {SEGV        11        segmentation violation}
    {SYS         12        bad argument to system call}
    {PIPE        13        write on a pipe with no one to read it}
    {ALRM        14        alarm clock}
    {TERM        15        software termination signal from kill}
    {URG         16        urgent condition on IO channel}
    {STOP        17        sendable stop signal not from tty}
    {TSTP        18        stop signal from tty}
    {CONT        19        continue a stopped process}
    {CHLD        20        to parent on child stop or exit}
    {TTIN        21        to readers pgrp upon background tty read}
    {TTOU        22        like TTIN for output if (tp->t_local&LTOSTOP)}
    {IO          23        input/output possible signal}
    {XCPU        24        exceeded CPU time limit}
    {XFSZ        25        exceeded file size limit}
    {VTALRM      26        virtual time alarm}
    {PROF        27        profiling time alarm}
    {WINCH       28        window size changes}
    {INFO        29        information request}
    {USR1        30        user defined signal 1}
    {USR2        31        user defined signal 2}
}

set posix_sigs {
    {HUP         1         hangup}
    {INT         2         interrupt}
    {QUIT        3         quit}
    {ILL         4         illegal instruction (not reset when caught)}
    {ABRT        6         abort()}
    {FPE         8         floating point exception}
    {KILL        9         kill (cannot be caught or ignored)}
    {SEGV        11        segmentation violation}
    {PIPE        13        write on a pipe with no one to read it}
    {ALRM        14        alarm clock}
    {TERM        15        software termination signal from kill}
    {STOP        17        sendable stop signal not from tty}
    {TSTP        18        stop signal from tty}
    {CONT        19        continue a stopped process}
    {CHLD        20        to parent on child stop or exit}
    {TTIN        21        to readers pgrp upon background tty read}
    {TTOU        22        like TTIN for output if (tp->t_local&LTOSTOP)}
    {USR1        30        user defined signal 1}
    {USR2        31        user defined signal 2}
}

set common_ps_keywords {
    {%cpu       percentage cpu usage (alias pcpu)}
    {%mem       percentage memory usage (alias pmem)}
    {uid        effective user ID}
    {user       user name (from uid)}
    {majflt     total page faults}
    {minflt     total page reclaims}
    {msgrcv     total messages received (reads from pipes/sockets)}
    {msgsnd     total messages sent (writes on pipes/sockets)}
    {vsz        virtual size in Kbytes (alias vsize)}
    {nice       nice value (alias ni)}
    {nsigs      total signals taken (alias nsignals)}
    {nswap      total swaps in/out}
    {pgid       process group number}
    {pid        process ID}
    {ppid       parent process ID}
    {rgid       real group ID}
    {ruid       real user ID}
    {ruser      user name (from ruid)}
    {start      time started}
    {time       accumulated cpu time, user + system (alias cputime)}
    {tpgid      control terminal process group ID}
    {tsiz       text size (in Kbytes)}
    {tty        full name of control terminal}
    {lim        memoryuse limit}
    {logname    login name of user who started the process}
}

set ALL_ps_keywords {
    {%cpu       percentage cpu usage (alias pcpu)}
    {%mem       percentage memory usage (alias pmem)}
    {acflag     accounting flag (alias acflg)}
    {cpu        short-term cpu usage factor (for scheduling)}
    {inblk      total blocks read (alias inblock)}
    {jobc       job control count}
    {ktrace     tracing flags}
    {ktracep    tracing vnode}
    {lim        memoryuse limit}
    {lstart     time started}
    {majflt     total page faults}
    {minflt     total page reclaims}
    {msgrcv     total messages received (reads from pipes/sockets)}
    {msgsnd     total messages sent (writes on pipes/sockets)}
    {nice       nice value (alias ni)}
    {nivcsw     total involuntary context switches}
    {nsigs      total signals taken (alias nsignals)}
    {nswap      total swaps in/out}
    {nvcsw      total voluntary context switches}
    {nwchan     wait channel (as an address)}
    {oublk      total blocks written (alias oublock)}
    {p_ru       resource usage (valid only for zombie)}
    {paddr      swap address}
    {pagein     pageins (same as majflt)}
    {pgid       process group number}
    {pid        process ID}
    {ppid       parent process ID}
    {pri        scheduling priority}
    {re         core residency time (in seconds; 127 = infinity)}
    {rgid       real group ID}

    {rlink      reverse link on run queue, or 0}
    {rss        resident set size}
    {rsz        resident set size + (text size / text use count) (alias rs- size)}
    {ruid       real user ID}
    {ruser      user name (from ruid)}
    {sess       session pointer}
    {sig        pending signals (alias pending)}
    {sigcatch   caught signals (alias caught)}
    {sigignore  ignored signals (alias ignored)}
    {sigmask    blocked signals (alias blocked)}
    {sl         sleep time (in seconds; 127 = infinity)}
    {start      time started}
    {svgid      saved gid from a setgid executable}
    {svuid      saved uid from a setuid executable}
    {tdev       control terminal device number}
    {time       accumulated cpu time, user + system (alias cputime)}
    {tpgid      control terminal process group ID}
    {tsess      control terminal session pointer}
    {tsiz       text size (in Kbytes)}
    {tt         control terminal name (two letter abbreviation)}
    {tty        full name of control terminal}
    {ucomm      name to be used for accounting}
    {uid        effective user ID}
    {upr        scheduling priority on return from system call (alias usrpri)}
    {user       user name (from uid)}
    {vsz        virtual size in Kbytes (alias vsize)}
    {wchan      wait channel (as a symbolic name)}
    {xstat      exit or stop status (valid only for stopped or zombie process)}
    {logname    login name of user who started the process}
}

set PROCESS_FLAGS {
    {SLOAD         0x0000001     in core}
    {SSYS          0x0000002     swapper or pager process}
    {SLOCK         0x0000004     process being swapped out}
    {SSWAP         0x0000008     save area flag}
    {STRC          0x0000010     process is being traced}
    {SWTED         0x0000020     another tracing flag}
    {SSINTR        0x0000040     sleep is interruptible}
    {SPAGE         0x0000080     process in page wait state}
    {SKEEP         0x0000100     another flag to prevent swap out}
    {SOMASK        0x0000200     restore old mask after taking signal}
    {SWEXIT        0x0000400     working on exiting}
    {SPHYSIO       0x0000800     doing physical I/O}
    {SVFORK        0x0001000     process resulted from vfork(2)}
    {SVFDONE       0x0002000     another vfork flag}
    {SNOVM         0x0004000     no vm, parent in a vfork}
    {SPAGV         0x0008000     init data space on demand, from vnode}
    {SSEQL         0x0010000     user warned of sequential vm behavior}
    {SUANOM        0x0020000     user warned of random vm behavior}
    {STIMO         0x0040000     timing out during sleep}
    {SNOCLDSTOP    0x0080000     no SIGCHLD when children stop}
    {SCTTY         0x0100000     has a controlling terminal}
    {SOWEUPC       0x0200000     owe process an addupc() call at next}
    {SSEL          0x0400000     selecting; wakeup/waiting danger}
    {SEXEC         0x0800000     process called exec(2)}
    {SHPUX         0x1000000     HP-UX process (HPUXCOMPAT)}
    {SULOCK        0x2000000     locked in core after swap error}
    {SPTECHG       0x4000000     pte's for process have changed}
}

set state_fields {
    {D Process in disk (or other short term, uninterruptable) wait.}
    {I Process that is idle (sleeping for longer than about 20 seconds).}
    {P Process in page wait.}
    {R Process is Runnable.}
    {S Process is sleeping for less than about 20 seconds.}
    {T Process is stopped.}
    {Z Process is dead (a ``zombie'').}
    {+ Process is in the foreground process group of its control terminal.}
    {< Process has raised CPU scheduling priority.}
    {> Process has specified a soft limit on memory requirements and is currently exceeding that limit; such a pro cess is (necessarily) not swapped.}
    {A  Process has asked for random page replacement (VA_ANOM, from vadvise(2),  for example, lisp(1) in a garbage collect).}
    {E The process is trying to exit.}
    {L The process has pages locked in core (for example, for raw I/O).}
    {N The process has reduced CPU scheduling priority (see setpriority(2)).}
    {S The process has asked for FIFO page replacement (VA_SEQL, from vadvise(2),  for example, a large image processing program using virtual memory to sequentially address voluminous data).}
    {s The process is a session leader.}
    {V The process is suspended during a vfork.}
    {W The process is swapped out.}
    {X The process is being traced or debugged.}
}

# defaults
set confirm_signals 1
set list_which_signals $common_ps_keywords

################################################################


# add one menu entry for each signal 
proc add_items {menu items} {
    foreach entry $items {
        set signame [lindex $entry 0]
        $menu add command -label $entry -command [list send_signal $signame]
    }
}


# split string into specified number of parts into list
proc stringToList {str parts} {
    set r [list]
    for {set i 0} {$i <= $parts-2} {incr i} {
        lappend r [lindex $str $i]
    }
    lappend r [join [lrange $str $parts-2 end] { }]
    return $r
}

# This runs ps and gets the results into a list of entries.
# FILTER is a variable used to filter the results, a la grep.  
proc get_unix_procs {filter} {
    global ps_args
    global sortoption

    # The PID column is the column which has the pid numbers in it. 
    # This can change depending on the options passed to 'ps'.
    global pid_column

    # save the old list scroll value 
    set oldyview [[w pstable] nearest 0]
    set oldsize [[w pstable] size]
    
    # Open a pipe to the "ps" program, with some args.
    set unix_procs_fd  [open "|ps $ps_args $sortoption"] 
    
    # Get the column headers, from the first line of output from ps.
    set header [gets $unix_procs_fd]

    set ps_columns $header
    set columns_ [concat {*}[lmap c $ps_columns {list 0 $c}]]
    [w pstable] configure -columns $columns_

    set pid_column [lsearch $ps_columns "PID"]
    if { $pid_column < 0 } {
        puts "Couldn't locate the PID column in the output from 'ps' \
                so I can't send a signal to a process:"
        puts $header
        exit 1
    }
    
    # Clear the list items.
    [w pstable] delete 0 end
    # Fill in listbox with process entries from 'ps' command output.
    while { [set i [gets $unix_procs_fd]] != {}  }  {
        if [regexp $filter $i] {
            [w pstable] insert end [stringToList $i [llength $ps_columns]]
        }
    }

    close $unix_procs_fd
    
    # if the list has not changed size much, try to preserve viewpoint
    if {abs([[w pstable] size] - $oldsize) < 2} {
        [w pstable] yview $oldyview
    }
    focus [w pstable]
}

proc update_unix_procs {} {
    variable greppat

    get_unix_procs $greppat
}

################################################################
#
# Dialog box for confirmation of kill command 
#
# Returns 1 if proceed, 0 if cancel
#

proc confirm_dialog {signame pids} {
    set dialog [widget::dialog [w tkps].sendSignalConfirm \
                    -modal local \
                    -separator 1 \
                    -type okcancel \
                    -parent [w tkps] \
                    -padding 10 \
                    -title "Confirm KILL command" \
                   ]
    ttk::frame $dialog.f
    label $dialog.f.header -text "Send $signame to processes $pids ?"

    pack $dialog.f.header -side top -fill x
    
    $dialog setwidget $dialog.f

    set r [$dialog display]
    destroy $dialog

    return [expr {$r eq "ok" ? 1 : 0}]
}

   
################################################################
proc msg_dialog {msg} {
    widget::dialog [w message [w tkps].message]\
        -modal local \
        -title Help \
        -parent [w tkps] \
        -separator 1 \
        -type ok \
        -padding 10
    set f [[w message] getframe]
    
    message $f.msg -text $msg -aspect 200

    pack $f.msg -side top -fill both

    [w message] display
    destroy [w message]
}


proc help_dialog {} {
    msg_dialog {This program will send a signal to the selected process. There \
are several equivalent ways to choose a signal to send. \

First, select a process from the list below, then select a signal to send to \
it, either using a button on the bottom of the window, or from one of the \
signal menus. The commonly used signals have their own buttons along the \
bottom of the window. 

It can be used shotcut key, `k' as KILL, `n' as INT, `q' as QUIT, \
`i' as IOT, `t' as TERM, `p' as STOP, `h' as HUP signal.

The signal menus contain the following (redundant) sets of signals:
 Common_Signals contains commonly used signals. 
 POSIX_Signals contains POSIX standard signals.
 All_signals contains all signals available. 

The "Filter" text entry field is essentially equivalent to "ps auxww | grep foo" for some value of foo. 

The "Find" entry box lets you select the first process matching the entry foo. 

The Options menu contains some configuration settings.
 "Confirm"  will pop up a dialog before executing a kill command.
 "List Common Process Info": double click on process pops up dialog of common useful process info.
 "List ALL Process Info": double click on process pops up dialog of ALL process info available through ps.
 "Set Update Period" adjusts the time between updating the display (and running "ps" again, which is expensive for some reason. 
 "Set Command Line Args" sets the option string which is sent to ps. It defaults to "auxww" }

}

proc about_box {} {
    msg_dialog [format {
The tkps browser was written by 
Ed Petron (epetron@leba.net)
Kidong Lee (kidong@shinbiro.com)

Originally written by Henry Minsky (hqm@ai.mit.edu)
    
This is Version %s, August 2001

Terms of the GNU Public License apply.
} $::version]
}


################################################################
# This ought to be a generic program to change a variable's value
proc change_update_period {} {
    global UPDATE_PERIOD MIN_UPDATE_PERIOD update_time
    global prompt

    set prev_update_time $UPDATE_PERIOD
    set update_time $UPDATE_PERIOD
    catch {destroy .update}
    # create top level window
    widget::dialog [w change [w tkps].change] \
        -title "Set update period" \
        -parent [w tkps] \
        -type okcancel \
        -separator 1 \
        -modal local \
        -padding 10

    set f [[w change] getframe]

    ttk::label $f.updateLabel -text "Update period (ms):"
    ttk::entry [w update_period $f.update] -justify right \
        -textvariable update_time

    pack $f.updateLabel -side left
    pack [w update_period] -side right
    
    set button [[w change] display]
    destroy [w change]

    # Don't let the updates go too fast.
    if {$button eq "ok"} {
        if {$update_time < $MIN_UPDATE_PERIOD} {
            set UPDATE_PERIOD $MIN_UPDATE_PERIOD
        } else {
            set UPDATE_PERIOD $update_time
        }
    } else {
        set UPDATE_PERIOD $prev_update_time
    }
}

################################################################
# Dialog to change args to ps. This should call a dialog subroutine.
#
proc change_ps_args {} {
    global ps_args args DEFAULT_PS_ARGS
    global prompt

    widget::dialog [w args [w tkps].args] \
        -parent [w tkps] \
        -modal local \
        -title "Set command line args" \
        -type okcancel \
        -padding 10 \
        -separator 1

    set args $ps_args
    set prev_ps_args $ps_args
    # create top level window

    set f [[w args] getframe]
        
    ttk::label $f.argsLabel -text {Command line args for "ps": }
    ttk::entry $f.args -textvariable args
    
    pack $f.argsLabel -side left
    pack $f.args -side right
    

    set button [[w args] display]
    destroy [w args]

    # Don't let the updates go too fast.
    if {$button eq "ok"} {
        if {$args != ""} {
            set ps_args $args
        } else {
            set ps_args $DEFAULT_PS_ARGS
        }
    } else {
        set ps_args $prev_ps_args
    }

    update_unix_procs
}

################################################################
# Routines to display a popup text widget with detailed info on a process


proc fill_info_window {pid widget} {
    global application

    set pidStatus [fileutil::cat /proc/$pid/status]
    set pidInfo [lrange [split $pidStatus \n] 0 2]
    set memInfo "Memory usage:\n[join [lsearch -all -inline {^Vm} $pidStatus] \n]"
    
    $widget configure -state normal
    $widget delete 1.0 end
    $widget insert end [join $pidInfo \n]
    $widget insert end "\n"
    set proc_fd [ open "|ps aux -p $pid" ]
    gets $proc_fd ps_header
    gets $proc_fd ps_line
    close $proc_fd
    set user [ lookup_proc_state $ps_header $ps_line USER ]
    set cpu [ lookup_proc_state $ps_header $ps_line %CPU ]
    set mem [ lookup_proc_state $ps_header $ps_line %MEM ]
    $widget insert end [ format "User:   %s\n" $user ]
    $widget insert end [ format "CPU%s:   %s\n" "%" $cpu ]
    $widget insert end [ format "MEM%s:   %s\n" "%" $mem ]
    
    $widget insert end $memInfo\n
    $widget insert end "\n\n"
#    $widget insert end [exec /usr/share/$application/signals $pid]
    $widget configure -state disabled
}

proc show_pinfo {} {
    set sp [selected_processes]
    foreach p $sp { 
        show_detailed_proc $p
    }
}

namespace eval ::ps {
    # Signal values
    array set SIGNALS {
        HUP     1
        INT     2
        QUIT    3
        ILL     4
        TRAP    5
        ABRT    6
        IOT     6
        BUS     7
        FPE     8
        KILL    9
        USR1   10
        SEGV   11
        USR2   12
        PIPE   13
        ALRM   14
        TERM   15
        STKFLT 16
        CHLD   17
        CONT   18
        STOP   19
        TSTP   20
        TTIN   21
        TTOU   22
        URG    23
        XCPU   24
        XFSZ   25
        VTALRM 26
        PROF   27
        WINCH  28
        IO     29
        POLL   29
        LOST   29
        PWR    30
    }
}

proc ::ps::get_parent_pid {pid} {
    return [lindex [regexp -inline {PPid:\s+(\d+)} [fileutil::cat /proc/$pid/status]] 1]
}

proc ::ps::family {pid} {
    set pattern {[0-9]}
    set children ""
    foreach f [glob /proc/$pattern*] {
        set f [file tail $f]
        set parent [get_parent_pid $f]
        if {$parent == $pid} {
            set children [format "%s %s" $children $f]
        }
    }

    return [list [get_parent_pid $pid] [string trim $children]]
}

proc ::ps::get_sig_masks {pid} {
    
}

proc ::ps::signals {pid} {
    variable SIGNALS

    
}

proc get_family_info {pid} {
    return [ps::family $pid]
}

proc build_child_list {plist widget} {
    $widget delete 0 end
    foreach p [lindex $plist end] {
        $widget insert end $p
    }
}

proc show_child_detail {widget} {
    show_detailed_proc [$widget get [$widget curselection]]
}

proc show_detailed_proc {pid} {
    set w [widget::dialog [w tkps].pinfo$pid \
               -modal local \
               -separator 1 \
               -type custom \
               -parent [w tkps] \
               -padding 10 \
               -title "Process $pid Info"]

    set family [get_family_info $pid]

    set ppid [lrange $family 0 0]

    set mf [$w getframe]

    labelframe $mf.process -text Process:
    text $mf.process.text -yscrollcommand [list $mf.process.scroll set]
    scrollbar $mf.process.scroll -command [list $mf.process.text yview]
 
    fill_info_window $pid $mf.process.text
 
    grid $mf.process.text -sticky news
    grid $mf.process.scroll -row 0 -column 1 -sticky ns
    grid columnconfigure $mf.process 0 -weight 1
    grid rowconfigure $mf.process 0 -weight 1
    
    labelframe $mf.fam -text Family:
    label $mf.fam.parent_label -text "Parent PID:"
    button $mf.fam.parent_button -text $ppid
    grid $mf.fam.parent_label
    grid $mf.fam.parent_button -row 0 -column 1 -columnspan 2 -sticky ew

    label $mf.fam.children_label -text Children:
    listbox $mf.fam.children_list -width 5 -yscrollcommand [list $mf.fam.children_scroll set]
    scrollbar $mf.fam.children_scroll -command [list $mf.fam.children_list yview]
    grid $mf.fam.children_label  -row 1 -column 0 -sticky n
    grid $mf.fam.children_list   -row 1 -column 1 -sticky news
    grid $mf.fam.children_scroll -row 1 -column 2 -sticky ns
    grid rowconfigure $mf.fam 1 -weight 1

    build_child_list $family $mf.fam.children_list

    $w add button -text "Kill process" -underline 0 -command [list $w close kill]
    $w add button -text "Dismiss"      -underline 0 -command [list $w close dismiss]

    grid $mf.process -sticky news
    grid $mf.fam -row 0 -column 1 -sticky ns
    grid columnconfigure $mf 0 -weight 1
    grid rowconfigure $mf 0 -weight 1

    bind $mf.fam.parent_button <ButtonPress-1> [list show_detailed_proc $ppid]
    bind $mf.fam.children_list <Double-ButtonPress-1> [list show_child_detail $mf.fam.children_list]

    bind $w <Alt-d> [list $w close dismiss]
    bind $w <Alt-k> [list $w close kill]

    if {[$w display] eq "kill"} {
        exec kill -KILL $pid
    }
    destroy $w
}

################################################################
# Default settings

option add *Menubutton.font fixed startupFile
option add *Menu.font fixed startupFile
option add *Button.font fixed startupFile
option add *list.font fixed
option add *header.font fixed
option add *process.text.font fixed startupFile

option add [string totitle $application].title "tkps - Process Manager" startupFile

catch {option read $systemRCFile startupFile}
catch {option read $userRCFile userDefault}

set sortoption ""

# The default update time of display is 10 seconds
# You can change it in the configure menu.
set MIN_UPDATE_PERIOD 2000
set UPDATE_PERIOD 10000 

# The default double click behavior
set USER_SIG KILL

# The default command line args to "ps"
set DEFAULT_PS_ARGS  "auxww"


################################################################

# get the doc string for a process state character (from ps -o state)
proc lookup_proc_state { header line key } {
    for {set i 0} {$key != [lindex $header $i] && \
                     "" != [lindex $header $i]} {incr i}  {}
    return [lindex $line $i]
}

################################################################
# Finds first entry matching $findpat 
#
# Also scrolls the display to make the item visible if it is not already.

proc find_unix_proc {findpat} {
    set entries [[w pstable] size]
    for {set i 0} {$i < $entries} {incr i} {
        if [regexp $findpat [[w pstable] get $i]] {
            [w pstable] yview $i
            [w pstable] select set $i
        } else {
            [w pstable] select clear $i
        }
    }
}


# Send signal looks at the currently selected entries in the listbox
# and sends the signal to all of them.
proc send_signal {signal} {
    global confirm_signals 
    set pids [selected_processes]
    set proceed 1
    if {$pids != {}} {
        if {$confirm_signals} {
            set proceed [confirm_dialog $signal $pids]
        }

        if {$proceed} {
            eval exec [format "kill -%s" $signal] $pids 
        }

        update_unix_procs
    }
}


# get the selected entries from the listbox and extract
# the pid fields from each selection
proc selected_processes {} {
    global pid_column

    lmap i [[w pstable] curselection] {
        lindex [[w pstable] get $i] $pid_column
    }
}


# The loop running in the background. 
# We want to make sure that we don't update if there is 
# a current selection in the window.
proc update_loop {} {
    variable UPDATE_PERIOD

    if {[[w pstable] curselection] == {}} {
        update_unix_procs
    }
    set ::currenttime [clock format [clock seconds]]
    after $UPDATE_PERIOD update_loop
}


proc main {psArgs} {
    variable common_ps_keywords
    variable ALL_ps_keywords
    variable common_sigs
    variable all_sigs
    variable posix_sigs
    variable ps_args
    variable DEFAULT_PS_ARGS


    tkapp [w tkps .tkps] \
        -name [option get . title Title] \
        -application TkPS \
        -defaultmenu 1 \
        -aboutcommand about_box

    ################################################################
    # Define menu bar items
    #

    # menu bar widget
    set m [[w tkps] getmenu]

    $m insert 2 cascade -label Options -menu $m.options -underline 0
    $m insert 3 cascade -label "Signal" -menu $m.signals -underline 0

    menu $m.options -tearoff 0
    menu $m.options.sortoptions
    $m.options.sortoptions add command \
        -label "USER" \
        -command {set sortoption "--sort user"}
    $m.options.sortoptions add command \
        -label "UID" \
        -command {set sortoption "--sort uid"}
    $m.options.sortoptions add command \
        -label "%CPU" \
        -command {set sortoption "--sort -pcpu"}
    $m.options.sortoptions add command \
        -label "PID" \
        -command {set sortoption -Op}

    $m.options add checkbutton \
        -label "Confirm Signals" \
        -variable confirm_signals
    $m.options add separator
    $m.options add radiobutton \
        -label "List Common Process Info" \
        -variable list_which_signals \
        -value $common_ps_keywords
    $m.options add radiobutton \
        -label "List ALL Process Info" \
        -variable list_which_signals \
        -value $ALL_ps_keywords
    $m.options add cascade \
        -label "Sort Processes by..." \
        -menu $m.options.sortoptions
    $m.options add separator
    $m.options add command \
        -label "Set Update Period..." \
        -command change_update_period
    $m.options add command \
        -label "Set 'ps' Command Line Args..." \
        -command change_ps_args

    menu $m.signals -tearoff 0

    menu $m.signals.com_signals
    $m.signals add cascade -label "Common Signals" -menu $m.signals.com_signals
    add_items $m.signals.com_signals $common_sigs

    menu $m.signals.all_signals
    $m.signals add cascade -label "POSIX Signals" -menu $m.signals.posix_signals
    add_items $m.signals.all_signals $all_sigs

    menu $m.signals.posix_signals
    $m.signals add cascade -label "All Signals" -menu $m.signals.all_signals
    add_items $m.signals.posix_signals $posix_sigs


    $m.help add command -label "Help" -command help_dialog

    ################################################################
    #
    # Create an entry field for restricting the visible entries.
    # This simulates the "ps auxww | grep foo" idiom. 
    #

    [w tkps] toolbar add label findlabel -text "Find:"
    [w tkps] toolbar add [entry [w findentry [[w tkps] gettoolbar].findentry] \
                              -textvariable findpat]
    [w tkps] toolbar add label greplabel -text "Filter:"
    [w tkps] toolbar add [entry [w filterentry [[w tkps] gettoolbar].filterentry] \
                              -textvariable greppat]
    [w tkps] toolbar add [ttk::button [[w tkps] gettoolbar].update \
                              -text "Update" \
                              -command {get_unix_procs $greppat}]

    bind [w filterentry] <Return> {update_unix_procs}
    bind [w findentry] <Return> {find_unix_proc $findpat}

    [w tkps] toolbar add space

    set mf [[w tkps] getframe]

    set sw [widget::scrolledwindow [w pstable $mf.pstable]]

    tablelist::tablelist [w pstable $sw.table]
    $sw setwidget [w pstable]
    pack $sw -fill both -expand true

    ttk::frame [w signals $mf.signals]
    # Make a button bar for the common signals
    foreach {signal key} {KILL k INT n QUIT q IOT i TERM t STOP p HUP h} {
        set name [string tolower $signal]
        ttk::button [w signals].[string tolower $signal] \
            -text $signal \
            -underline 0 \
            -command [list send_signal $signal]
        pack [w signals].[string tolower $signal] -side left -padx 5 -pady 5
        bind [[w pstable] bodytag] <[string toupper $key]> [list send_signal $signal]
    }
    pack [w signals] -side bottom -fill x

    [w tkps] statusbar add label -- -textvariable currenttime

    ################################################################
    # Set up args to 'ps'.
    # We either got args from the command line, or we default
    # to auxww
    
    if {[llength $psArgs] > 0} {
        set ps_args [lindex $psArgs 0] 
    } else {
        set ps_args $DEFAULT_PS_ARGS
    }

    # Set up bindings for the browser.

    bind [w pstable]  <Button-1> {focus [w pstable]}
    bind [[w pstable] bodytag] <Double-Button-1> {
        set oldconfirm $confirm_signals
        set confirm_signals 1
        foreach i [[w pstable] curselection] {show_pinfo}
        set confirm_signals $oldconfirm
    }
    bind [[w pstable] bodytag] <Return> {
        set oldconfirm $confirm_signals
        set confirm_signals 1
        foreach i [[w pstable] curselection] {show_pinfo}
        set confirm_signals $oldconfirm
    }

    bind [w tkps] <F1> help_dialog

    wm withdraw .

    update_loop
}


main $argv
